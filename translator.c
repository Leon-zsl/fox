#include "fox.h"
#include "symbol.h"
#include "syntax.h"
#include "translator.h"

int yylex(void);
int yyparse(void);

void yyset_in(FILE *in);
void yyset_out(FILE *out);
void yyset_lineno(int lineno);
void yyset_filename(const char *name);

extern struct syntax_tree *parse_tree;
extern struct symbol_table *parse_table;

int parse(const char *filename,
		  struct syntax_tree **tree,
		  struct symbol_table **table) {
	FILE *fp = fopen(filename, "rb");
	if(!fp) {
		log_error("open file failed %s", filename);
		return 0;
	}

	yyset_in(fp);
	yyset_out(stdout);
	yyset_filename(filename);
	yyset_lineno(1);

	parse_tree = syntax_tree_create();
	parse_table = symbol_table_create();	
	int val = yyparse();
	fclose(fp);

	if(val) {
		log_error("parse lua program failed: %s", filename);
		syntax_tree_release(parse_tree);
		symbol_table_release(parse_table);
		return 0;
	}
	
	log_info("parse lua program succeed: %s", filename);
	*tree = parse_tree;
	*table = parse_table;
	return 1;
}

struct translator {
	struct syntax_tree *tree;
	struct symbol_table *table;
	FILE *fp;
};

static struct translator *translator_create(struct syntax_tree *tree,
											struct symbol_table *table,
											const char *filename) {
	FILE *fp = fopen(filename, "wb");
	if(!fp) {
		log_error("open file failed %s", filename);
		return NULL;
	}

	struct translator *t = malloc(sizeof(struct translator));
	t->tree = tree;
	t->table = table;
	t->fp = fp;
	return t;
}

static void translator_release(struct translator *t) {
	if(!t) return;

	fclose(t->fp);
	free(t);
}

static int translate_syntax_node(struct translator *t, struct syntax_node *n);

int translate(const char *filename,
			  struct syntax_tree *tree,
			  struct symbol_table *table) {
	if(!tree || !tree->root || !table) {
		log_error("syntax tree or symbol table is invalid");
		return 0;
	}

	struct translator *t = translator_create(tree, table, filename);
	if(!t) {
		log_error("create translator failed");
		return 0;
	}

	fprintf(t->fp, "//CODE GENERATED BY FOX, A LUA->JS TRANSLATOR!\n\n");
	fflush(t->fp);
	int val = translate_syntax_node(t, tree->root);
	translator_release(t);
	if(!val) {
		log_error("translate lua program failed:%s", filename);
		return 0;
	}

	log_info("translate lua program succeed:%s", filename);
	return 1;
}

static int trans_syntax_chunk(struct translator *t, struct syntax_chunk *chunk);
static int trans_syntax_block(struct translator *t, struct syntax_block *block);
static int trans_syntax_statement(struct translator *t, struct syntax_statement *stmt);
static int trans_syntax_expression(struct translator *t, struct syntax_expression *exp);
static int trans_syntax_variable(struct translator *t, struct syntax_variable *var);
static int trans_syntax_function(struct translator *t, struct syntax_function *func);
static int trans_syntax_functioncall(struct translator *t, struct syntax_functioncall *fcall);
static int trans_syntax_argument(struct translator *t, struct syntax_argument *arg);
static int trans_syntax_table(struct translator *t, struct syntax_table *table);
static int trans_syntax_field(struct translator *t, struct syntax_field *field);

static int func_is_method(const char *funcname) {
	return strstr(funcname, ":") != NULL;
}

static int trans_syntax_node_children(struct translator *t, struct syntax_node *n) {
	struct syntax_node *c = n->children;
	while(c) {
		if(!translate_syntax_node(t, c)) return 0;
		c = c->next;
	}
	return 1;
}

static int trans_syntax_chunk(struct translator *t, struct syntax_chunk *chunk) {
	return trans_syntax_node_children(t, &chunk->n);
}

static int trans_syntax_block(struct translator *t, struct syntax_block *block) {
	fprintf(t->fp, "{\n");
	int val = trans_syntax_node_children(t, &block->n);
	fprintf(t->fp, "}\n");
	return val;
}

static int trans_syntax_statement(struct translator *t, struct syntax_statement *stmt) {
	log_info("trans statement, tag:%s", syntax_statement_tag_string(stmt->tag));
	
	switch(stmt->tag) {
	case STMT_EMPTY:
		return 1;
	case STMT_LABEL:
	case STMT_GOTO:
	{
		log_error("unsupport stmt:%s", syntax_statement_tag_string(stmt->tag));
		return 0;
	}
	case STMT_BREAK:
	{
		fprintf(t->fp, "break");
		return 1;
	}
	case STMT_RETURN:
	{
		struct syntax_node *p = (&stmt->n)->parent->parent;
		//module return
		if(p->type == STX_CHUNK) {
			fprintf(t->fp, "module.exports = ");			
		} else {
			fprintf(t->fp, "return ");
		}
		return trans_syntax_node_children(t, &stmt->n);
	}
	case STMT_DO:
	{
		return trans_syntax_node_children(t, &stmt->n);
	}
	case STMT_WHILE:
	{
		fprintf(t->fp, "while (");
		int val = trans_syntax_expression(t, (struct syntax_expression *)syntax_node_child(&stmt->n, 0));
		if(!val) return 0;
		fprintf(t->fp, ")");
		return trans_syntax_block(t, (struct syntax_block *)syntax_node_child(&stmt->n, 1));
	}
	case STMT_REPEAT:
	{
		fprintf(t->fp, "do ");
		int val = trans_syntax_block(t, (struct syntax_block *)syntax_node_child(&stmt->n, 0));
		if(!val) return 0;
		fprintf(t->fp, "while (");
		val = trans_syntax_expression(t, (struct syntax_expression *)syntax_node_child(&stmt->n, 1));
		if(!val) return 0;
		fprintf(t->fp, ")");
		return 1;
	}
	case STMT_FOR_IN:
	{
		//todo:
		return 1;
	}
	case STMT_FOR_IT:
	{
		//todo:
		return 1;
	}
	case STMT_IF:
	{
		//todo:
		return 1;
	}
	case STMT_ELSE:
	{
		//todo:
		return 1;
	}
	case STMT_ELSEIF:
	{
		//todo:
		return 1;
	}
	case STMT_VAR:
	{
		//todo:
		return 1;
	}
	case STMT_LOCAL_VAR:
	{
		fprintf(t->fp, "var %s\n", stmt->value.name);
		char *p = stmt->value.name;
		for(int i = 0; i < syntax_node_children_count(&stmt->n); i++) {
			while(*p != '\0' && *p != ',') {
				fputc(*p, t->fp);
				p++;
			}
			fprintf(t->fp, " = ");
			int val = trans_syntax_expression(t, (struct syntax_expression *)syntax_node_child(&stmt->n, i));
			if(!val) return 0;
			fprintf(t->fp, "\n");
			p++;
		}
		return 1;
	}
	case STMT_FUNC:
	case STMT_LOCAL_FUNC:
	{
		return trans_syntax_node_children(t, &stmt->n);
	}
	case STMT_FCALL:
	{
		return trans_syntax_node_children(t, &stmt->n);
	}
	case STMT_INVALID:
	default:
		log_error("illeagal stmt:%d", stmt->tag);
		return 0;
	}

	fflush(t->fp);
}

static int trans_syntax_function(struct translator *t, struct syntax_function *func) {
	log_info("trans function, name:%s", func->name ? func->name : "");
	
	fprintf(t->fp, "function ");
	char *p = func->name;
	while(p && *p != '\0') {
		if(*p == ':') {
			fputc('.', t->fp);
		} else {
			fputc(*p, t->fp);
		}
		p++;
	}
	
	fprintf(t->fp, "(");
	if(func_is_method(func->name)) {
		if(func->pars) {
			fprintf(t->fp, "self,");
		} else {
			fprintf(t->fp, "self");
		}
	} else {
		if(func->pars) {
			if(strstr(func->pars, "...")) {
				log_error("unsupported variable parameters:%s, %s",
						  func->name ? func->name : "",
						  func->pars);
				return 0;
			}
			fprintf(t->fp, func->pars);
		}
	}
	fprintf(t->fp, ")");

	return trans_syntax_node_children(t, &func->n);
}

static int trans_syntax_functioncall(struct translator *t, struct syntax_functioncall *fcall) {
	return trans_syntax_node_children(t, &fcall->n);
}

static int trans_syntax_expression(struct translator *t, struct syntax_expression *expr) {
	if(expr->tag == EXP_NUMBER) {
		log_info("trans expression, tag:%s, number:%f",
				 syntax_expression_tag_string(expr->tag),
				 expr->value.number);
	} else if(expr->tag == EXP_STRING) {
		log_info("trans expression, tag:%s, string:%s",
				 syntax_expression_tag_string(expr->tag),
				 expr->value.string);
	} else {
		log_info("trans expression, tag:%s", syntax_expression_tag_string(expr->tag));
	}

	return trans_syntax_node_children(t, &expr->n);
}

static int trans_syntax_variable(struct translator *t, struct syntax_variable *var) {
	log_info("trans variable, tag:%s, name:%s",
			 syntax_variable_tag_string(var->tag),
			 var->name ? var->name : "");
	return trans_syntax_node_children(t, &var->n);
}

static int trans_syntax_argument(struct translator *t, struct syntax_argument *arg) {
	return trans_syntax_node_children(t, &arg->n);
}

static int trans_syntax_table(struct translator *t, struct syntax_table *st) {
	return trans_syntax_node_children(t, &st->n);
}

static int trans_syntax_field(struct translator *t, struct syntax_field *field) {
	log_info("trans field, tag:%s, name:%s",
			 syntax_field_tag_string(field->tag),
			 field->name ? field->name : "");
	return trans_syntax_node_children(t, &field->n);
}

static int translate_syntax_node(struct translator *t, struct syntax_node *n) {
	log_info("trans node, type:%s, line:%d, depth:%d, children:%d",
			 syntax_node_type_string(n->type),
			 n->lineno,
			 syntax_node_depth(n),
			 syntax_node_children_count(n));

	int val = 0;
	void *node = n;
	switch(n->type) {
	case STX_CHUNK:
		val = trans_syntax_chunk(t, node);
		break;
	case STX_BLOCK:
		val = trans_syntax_block(t, node);
		break;
	case STX_STATEMENT:
		val = trans_syntax_statement(t, node);
		break;
	case STX_EXPRESSION:
		val = trans_syntax_expression(t, node);
		break;
	case STX_VARIABLE:
		val = trans_syntax_variable(t, node);
		break;
	case STX_FUNCTION:
		val = trans_syntax_function(t, node);
		break;
	case STX_FUNCTIONCALL:
		val = trans_syntax_functioncall(t, node);
		break;
	case STX_ARGUMENT:
		val = trans_syntax_argument(t, node);
		break;
	case STX_TABLE:
		val = trans_syntax_table(t, node);
		break;
	case STX_FIELD:
		val = trans_syntax_field(t, node);
		break;
	default:
		log_error("unknown syntax node type to translate:%d", n->type);
		break;
	}
	return val;
}

